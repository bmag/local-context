#+TITLE: local-context
Generate elisp code to create frame-local features for Emacs

* Motivation

* How to Use This
  First, run =M-x make-context= to generate context-handling code. The code will
  be written to a =*temporary context*= buffer. You will be asked for a prefix
  and a context buffer name. The generated function- and variable- names will
  all start with =PREFIX-context=, the reason for this is to avoid conflicts
  with other context-aware packages.

  Second, copy the generated code to your package's source code.

  Third, convert your code to use context. What you need to do here depends on
  how your package is implemented. If you're lucky, this is all you'll have to
  do:
  - convert global variables to context variables
  - add context creation where appropriate
  
** Converting Global Variables to Context Variables
   Usually, you will have some global variables that you will need to convert to
   context variables.

   | Action    | Regular Variable       | Context Variable                 |
   |-----------+------------------------+----------------------------------|
   | define    | ~defvar~ form          | add to ~context-state-variables~ |
   | get value | ~varname~              | ~(context-get 'varname)~         |
   | set value | ~(setq varname value)~ | ~(context-set 'varname value)~   |
   
** Creating Contexts
   To create a context, just call =context-create-buffer= or
   =context-get-buffer-create=. If your package has a side buffer, e.g. like
   Neotree, you can move the buffer initalization into =context-create-buffer=,
   and then replace the original =get-buffer-create= with
   =context-get-buffer-create=.

* Implementation Details
  Note: in the generated code, all function and variable names begin with a
  prefix, for example =mypkg-context-get-buffer=. For simplicity, the prefix is
  omitted from the names below. When you read =context-get-buffer=, in your code
  you should look for =PREFIX-context-buffer=.

** Locality of Contexts
   The contexts generated by Context are /frame-local/. You cannot have
   window-local contexts, and you cannot safely share a context between several
   frames. However, when [[https://github.com/wasamasa/eyebrowse][eyebrowse]] or [[https://github.com/Bad-ptr/persp-mode.el][persp-mode]] are installed, contexts can be
   workspace-local or perspective-local respectively. Eyebrowse and persp-mode
   locality is enabled by setting =context-want-eyebrwose-local= and
   =context-want-persp-mode-local=. These variables are nil by default, but of
   course you can change their default value. The user can control if he/she
   wants eyebrowse/persp-mode locality by setting these variables /before/
   loading your package.

   /Important/: when using both eyebrowse and persp-mode together, the behavior
   is not defined.

*** Possible Future Improvements
    - let multiple frames share a context
    - define behavior when eyebrowse and peresp-mode are used together

** Creating a New Context
   Creating a new context is done by calling =context-create-buffer=. This
   function creates a new context buffer, initializes the context variables, and
   attaches the context buffer to the current frame. If you need to do some
   extra initialization, e.g. change the buffer's major mode,
   =context-create-buffer= is a good place to do it. If your package has a
   dedicated buffer, like Neotree does, that buffer can double as the context
   buffer.

   Creating a new context in a frame that already has a context, will reset the
   frame's context.

*** Attaching a Context to a Frame
    A context is attached to a frame by setting the =context-buffer= frame
    parameter to the context's context buffer, and updating the context's other
    frame parameters according to the buffer's local variables. This is done in
    =context-attach-to-frame=.

*** Detaching a Context from a Frame
    A context is detached from a frame by setting the =context-buffer= frame
    parameter to nil. This is done in =context-detach-from-frame=. This /does
    not/ kill the context buffer. If you wish, you can juggle contexts between
    frames by appropriate calls to =context-attach-to-frame=,
    =context-detach-from-frame= and =context-store-state=.

** Context Variables
   Context variables are context-local variables. They are stored in two places:
   as buffer-local variables in the context buffer, and as frame parameters. The
   frame parameters are more dynamic - =context-set= and =context-get= access
   the frame parameters, while the buffer-local variables are used for
   persistence.

   The frame parameters and the buffer-local variables are synchronized in two
   places: the frame is updated according to the buffer in
   =context-attach-to-frame=, and the buffer is updated according to the frame
   in =context-store-state=.

   When eyebrowse-locality or persp-mode-locality is enabled,
   =context-attach-to-frame= and =context-store-state= are called from the
   appropriate hooks.

*** Defining Context Variables
    The context variables are defined in the global variable
    =context-state-variables=, which is a list of =context-state-var= entries.
    For example, here we define two context variables:
    #+BEGIN_SRC elisp
      (defvar context-state-variables
        (mapcar (lambda (item)
                  (apply #'context-state-var item))
                '(;; (var-name name-as-buffer-local-var [init-value [init-form]])
                  (counter PREFIX-context-counter 0)
                  (creation-time PREFIX-context-creation-time nil (current-time)))))
    #+END_SRC
    Lets look at the definition of the context variable =counter=: The first
    value =counter= defines the name of the context variable's frame parameter
    to be =PREFIX-context-counter= - the prefix =PREFIX-context-= is added
    automatically. The second value =PREFIX-context-counter= defines the name
    of the context variable as a buffer-local variable to be
    =PREFIX-context-counter= - the prefix is not added automatically here. The
    third value defines the initial value. Every time a context is created,
    =counter= will be initialized to =0= in the new context.

    In the definition of =creation-time=, the third value is nil and the fourth
    value is non-nil. In this case, the fourth value is an initial form
    (expression) that is evaluated at context initialization time. Every time a
    context is created, =creation-time= will be initialized to =(current-time)=.

*** Accessing Context Variables
    Access is as simple as calling =context-get= and =context-set=. For example,
    lets increase the =counter= context variable that was defined in the
    previous example:
    #+BEGIN_SRC elisp
      (context-state-set 'counter (+ 1 (context-state-get 'counter)))
    #+END_SRC
  
** Context Buffer
   The context-handling code creates a single buffer per context, which is
   called the context buffer. The name of the context buffer is generated by
   #+BEGIN_SRC elisp
     (generate-new-buffer-name context-base-name)
   #+END_SRC
   So if =PREFIX-context-base-name= is =*ctx buff*=, the generated buffer names
   are =*ctx buff*<1>=, =*ctx buff*<2>=, etc.
